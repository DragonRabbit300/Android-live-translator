<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Real-Time Translator (Samsung/Android Fixed)</title>

  <style>
    body { font-family: Arial, sans-serif; text-align: center; padding: 20px; }
    button {
      padding: 12px 20px; margin: 10px; font-size: 16px; border-radius: 10px;
      border: none; background: #007BFF; color: white; cursor: pointer;
    }
    button:disabled { background: gray; cursor: not-allowed; }
    select { padding: 8px; font-size: 16px; margin: 5px; }

    #translations, #liveText {
      margin-top: 20px; text-align: left; max-width: 520px; margin-left: auto; margin-right: auto;
      background: #f8f8f8; padding: 15px; border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    #translations { max-height: 280px; overflow-y: auto; }

    .chunk {
      padding: 8px 42px 8px 8px; margin-bottom: 8px; border-radius: 8px;
      background-color: #e0f7fa; position: relative; line-height: 1.25;
      word-wrap: break-word;
    }
    .replayBtn {
      position: absolute; right: 8px; top: 50%; transform: translateY(-50%);
      background: #007BFF; color: white; border: none; border-radius: 6px;
      padding: 4px 8px; cursor: pointer; font-size: 12px;
    }
    #liveText { font-style: italic; color: #333; }
    .small { font-size: 12px; color: #555; margin-top: 10px; max-width: 520px; margin-left:auto; margin-right:auto; text-align:left; }
    .warn { color: #b00020; }
  </style>
</head>

<body>
  <h1>Real-Time Translator üåç</h1>
  <p>Select languages and press Start:</p>

  <button id="enableAudioBtn">üîä Enable Audio</button>

  <label for="fromLang">üé§ Input Language:</label>
  <select id="fromLang">
    <option value="en-US">English</option>
    <option value="es-ES">Spanish</option>
    <option value="fr-FR">French</option>
    <option value="de-DE">German</option>
    <option value="sv-SE">Swedish</option>
  </select>

  <label for="toLang">üîä Output Language:</label>
  <select id="toLang">
    <option value="en-US">English</option>
    <option value="es-ES">Spanish</option>
    <option value="fr-FR">French</option>
    <option value="de-DE">German</option>
    <option value="sv-SE">Swedish</option>
  </select>

  <br /><br />

  <button id="toggleBtn">‚ñ∂ Start</button>
  <button id="replayAllBtn">üîÅ Replay All</button>
  <button id="clearBtn">üßπ Clear All</button>

  <div id="liveText">üéôÔ∏è Live text will appear here...</div>
  <div id="translations"></div>

  <div class="small" id="status"></div>

  <script>
    // =========================
    // Standalone Samsung/Android Translator (FIXED)
    // Fixes:
    // 1) De-duplication for Android SpeechRecognition repeats
    // 2) Clear mic status
    // 3) Lock language selects while recording
    // 4) Cancel speech before speaking to avoid overlaps
    // =========================

    // ---------- UI ----------
    const enableAudioBtn = document.getElementById("enableAudioBtn");
    const toggleBtn = document.getElementById("toggleBtn");
    const replayAllBtn = document.getElementById("replayAllBtn");
    const clearBtn = document.getElementById("clearBtn");
    const translationsDiv = document.getElementById("translations");
    const liveText = document.getElementById("liveText");
    const fromLang = document.getElementById("fromLang");
    const toLang = document.getElementById("toLang");
    const statusEl = document.getElementById("status");

    // ---------- Speech Recognition ----------
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let listening = false;

    // Audio/TTS
    let audioEnabled = false;

    // Chunking buffers
    let stableText = "";     // accumulated "final" text
    let lastPartial = "";    // most recent interim text
    let silenceTimer = null;
    let translating = false;

    // Replay store
    let allTranslations = [];

    // Chunk tuning
    const SILENCE_MS = 900;
    const MAX_CHUNK_CHARS = 180;
    const PUNCTUATION_RE = /[.!?„ÄÇÔºÅÔºü]$/;

    function setStatus(msg, isWarn=false) {
      statusEl.className = "small" + (isWarn ? " warn" : "");
      statusEl.textContent = msg || "";
    }

    function updateUIForListening() {
      fromLang.disabled = listening;
      toLang.disabled = listening;
      setStatus(listening ? "üéß Listening‚Ä¶" : "‚èπÔ∏è Stopped");
    }

    // ---------- Safety: HTML escaping ----------
    function escapeHtml(str) {
      return String(str)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    // ---------- Android de-dup helper ----------
    // Android interim/final results often resend previous words.
    // This tries to keep only the newest text without repeating.
    function appendUnique(existing, incoming) {
      const e = (existing || "").trim();
      const i = (incoming || "").trim();
      if (!e) return i;
      if (!i) return e;

      // If incoming contains existing at the start, incoming is "more complete"
      if (i.startsWith(e)) return i;

      // If existing already ends with incoming, keep existing
      if (e.endsWith(i)) return e;

      // Otherwise, append (best effort)
      return (e + " " + i).trim();
    }

    // ---------- MyMemory translate ----------
    async function translateText(text, fromBcp47, toBcp47) {
      const from = fromBcp47.split("-")[0]; // en-US -> en
      const to = toBcp47.split("-")[0];
      const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${from}|${to}`;
      const res = await fetch(url);
      const data = await res.json();
      return data?.responseData?.translatedText || "(translation failed)";
    }

    // ---------- Speech synthesis ----------
    function pickBestVoice(lang) {
      const voices = speechSynthesis.getVoices() || [];
      if (!voices.length) return null;

      const exact = voices.find(v => (v.lang || "").toLowerCase() === lang.toLowerCase());
      if (exact) return exact;

      const base = lang.split("-")[0].toLowerCase();
      return voices.find(v => (v.lang || "").toLowerCase().startsWith(base)) || null;
    }

    function speak(text, lang) {
      if (!text) return;
      const u = new SpeechSynthesisUtterance(text);
      u.lang = lang;

      const voice = pickBestVoice(lang);
      if (voice) u.voice = voice;

      // Prevent stacking overlapping speech on Android
      speechSynthesis.cancel();
      speechSynthesis.speak(u);
    }

    // Some Android devices load voices async
    window.speechSynthesis.onvoiceschanged = () => {};

    // ---------- Add translation chunk ----------
    function addTranslation(original, translated) {
      const chunkDiv = document.createElement("div");
      chunkDiv.className = "chunk";
      chunkDiv.innerHTML = `<strong>${escapeHtml(original)}</strong><br/>‚Üí ${escapeHtml(translated)}`;

      const replayBtn = document.createElement("button");
      replayBtn.textContent = "üîä";
      replayBtn.className = "replayBtn";
      replayBtn.onclick = () => speak(translated, toLang.value);

      chunkDiv.appendChild(replayBtn);
      translationsDiv.appendChild(chunkDiv);
      translationsDiv.scrollTop = translationsDiv.scrollHeight;

      allTranslations.push(translated);
    }

    // ---------- Commit current chunk ----------
    async function commitChunk(text) {
      const cleaned = (text || "").trim();
      if (!cleaned || translating) return;

      translating = true;

      // reset buffers
      stableText = "";
      lastPartial = "";
      if (silenceTimer) clearTimeout(silenceTimer);
      silenceTimer = null;

      liveText.textContent = "üéôÔ∏è Translating‚Ä¶";

      try {
        const translated = await translateText(cleaned, fromLang.value, toLang.value);
        addTranslation(cleaned, translated);
        liveText.textContent = "üéôÔ∏è ‚Ä¶";
        if (audioEnabled) speak(translated, toLang.value);
      } catch (e) {
        console.warn(e);
        addTranslation(cleaned, "(translation failed)");
        liveText.textContent = "üéôÔ∏è ‚Ä¶";
      } finally {
        translating = false;
      }
    }

    // ---------- Init recognition ----------
    function initRecognition() {
      if (!SpeechRecognition) {
        setStatus("Speech Recognition not supported in this browser. Use Chrome or Samsung Internet.", true);
        alert("Speech Recognition not supported in this browser on this device. Use Chrome or Samsung Internet.");
        return null;
      }

      const r = new SpeechRecognition();
      r.continuous = true;
      r.interimResults = true;
      r.maxAlternatives = 1;

      r.onstart = () => setStatus("üéß Listening‚Ä¶");
      r.onerror = (e) => {
        console.warn("Recognition error:", e);
        setStatus("‚ö†Ô∏è Mic/recognition error: " + (e.error || "unknown") + " (try stopping and starting again)", true);
      };

      // Android often ends recognition randomly; restart if user is still listening
      r.onend = () => {
        if (listening) {
          setStatus("üîÅ Restarting listening‚Ä¶");
          setTimeout(() => {
            try { r.start(); }
            catch (err) {
              console.warn("Restart failed:", err);
              setTimeout(() => { try { r.start(); } catch(e2) {} }, 800);
            }
          }, 250);
        } else {
          updateUIForListening();
        }
      };

      r.onresult = (event) => {
        if (silenceTimer) clearTimeout(silenceTimer);

        let interim = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const t = (event.results[i][0].transcript || "").trim();
          if (!t) continue;

          if (event.results[i].isFinal) {
            // ‚úÖ FIX: de-dup instead of blindly appending
            stableText = appendUnique(stableText, t);
            lastPartial = "";
          } else {
            interim = t;
            lastPartial = t;
          }
        }

        const display = (stableText + " " + (interim || "")).trim();
        liveText.textContent = display ? ("üéôÔ∏è " + display) : "üéôÔ∏è ‚Ä¶";

        // commit on punctuation end
        if (display && PUNCTUATION_RE.test(display)) {
          commitChunk(display);
          return;
        }

        // commit if too long
        if (display.length >= MAX_CHUNK_CHARS) {
          commitChunk(display);
          return;
        }

        // commit after silence gap
        silenceTimer = setTimeout(() => {
          const finalish = (stableText + " " + lastPartial).trim();
          if (finalish) commitChunk(finalish);
        }, SILENCE_MS);
      };

      return r;
    }

    // ---------- Buttons ----------
    enableAudioBtn.addEventListener("click", () => {
      audioEnabled = true;
      enableAudioBtn.disabled = true;
      enableAudioBtn.textContent = "‚úÖ Audio Enabled";
      speak("Audio enabled", toLang.value);
    });

    toggleBtn.addEventListener("click", () => {
      if (!recognition) recognition = initRecognition();
      if (!recognition) return;

      if (!listening) {
        recognition.lang = fromLang.value; // en-US, es-ES, etc.
        try {
          recognition.start();
          listening = true;
          toggleBtn.textContent = "‚èπ Stop";
          updateUIForListening();
        } catch (e) {
          console.warn("start error:", e);
          setStatus("‚ö†Ô∏è Could not start mic. Grant permission, then tap Start again.", true);
        }
      } else {
        listening = false;
        toggleBtn.textContent = "‚ñ∂ Start";
        updateUIForListening();

        try { recognition.stop(); } catch(e) {}

        // flush what we have
        const finalish = (stableText + " " + lastPartial).trim();
        if (finalish) commitChunk(finalish);

        if (silenceTimer) clearTimeout(silenceTimer);
        silenceTimer = null;
      }
    });

    replayAllBtn.addEventListener("click", () => {
      if (allTranslations.length === 0) {
        alert("No translations to replay yet!");
        return;
      }

      // Chain playback (more reliable than timeouts on mobile)
      let i = 0;
      speechSynthesis.cancel();

      const playNext = () => {
        if (i >= allTranslations.length) return;
        const u = new SpeechSynthesisUtterance(allTranslations[i]);
        u.lang = toLang.value;
        const v = pickBestVoice(toLang.value);
        if (v) u.voice = v;
        u.onend = () => { i++; playNext(); };
        speechSynthesis.speak(u);
      };

      playNext();
    });

    clearBtn.addEventListener("click", () => {
      if (!confirm("Are you sure you want to clear all translations?")) return;
      translationsDiv.innerHTML = "";
      liveText.textContent = "üéôÔ∏è Live text will appear here...";
      allTranslations = [];
      stableText = "";
      lastPartial = "";
      if (silenceTimer) clearTimeout(silenceTimer);
      silenceTimer = null;
      speechSynthesis.cancel();
      setStatus("");
    });

    // Initial status
    updateUIForListening();
    setStatus("Tip: On Samsung, open in Chrome or Samsung Internet. Tap 'Enable Audio' before speech playback.");
  </script>
</body>
</html>

